package com.exsoinn.ie.rule;

import com.exsoinn.ie.util.CommonUtils;
import com.exsoinn.util.epf.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * All this class does is execute the rules in the order given, and join their outputs using the delimiter character
 * configured during object initialization.
 *
 * Created by QuijadaJ on 8/4/2017.
 */
public class JoinOutputRule extends AbstractRule {
    private final List<Rule> rules;
    private final char delimiter;
    private final boolean flattenedMultiValueOutputs;


    /**
     * Have to declare below class public so that JavaScript consumer can have visibility to its
     * public methods
     */
    public static class Builder implements com.exsoinn.ie.util.Builder<JoinOutputRule> {
        // Required parameters
        private final String name;
        private final List<String> ruleNames;

        // Optional parameters
        private char delimiter = ' ';
        private boolean flattenedMultiValueOutputs = true;

        /*
         * Constructor
         */
        Builder(String pName, List<String> pRuleNames) {
            name = pName;
            ruleNames = new ArrayList<>(pRuleNames);
        }


        /**
         * Delimiter to use to separate the rule outputs. By default the delimeter used is simply
         * a single blank space.
         * @param pDelim
         * @return
         */
        public Builder delimiter(char pDelim) {
            delimiter = pDelim;
            return this;
        }


        /**
         * When <code>true</code>, all rule results are returned as a single flattened list, regardless of any individual
         * rule(s) that yielded multi-value results - those will get included in the final list of rule outputs as if each was
         * generated by its own rule
         * When false, the the output will be multiple output lists, delimited by {@link Utilities#MULTI_VAL_DELIM}. Each of those
         * lists result from concatenating each individual multi-output value with the results of other lists. For example
         * let's say "ruleSingleValueOutput" gives output "OUT", and "ruleMultiValueOutput" gives outputs "OUT1 OUT2 OUT3". The final
         * result generated will look like "OUT OUT1||OUT OUT2||OUT OUT3". If a another rule yet, say
         * "anotherRuleMultiValueOutput" also gave multiple outputs "OUT4 OUT5 OUT6", then the final output
         * would now be "OUT OUT1 OUT4||OUT OUT2 OUT4||OUT OUT3 OUT4||OUT OUT3 OUT5||OUT OUT3 OUT5||OUT OUT3 OUT5||
         * OUT OUT3 OUT6||OUT OUT3 OUT6||OUT OUT3 OUT6||". Notice how each new value in the rule's multi-val output expanded
         * the number of sub-lists. In mathematical terms, at each iteration of a rule, the sub-lists size grows
         * at the rate "SL * RU", where "SL" is the number of sub-lists present during that iteration of a rule, and "RU" is
         * the number of outputs that the current rule being iterated over gave.
         * By default, this parameter value is <code>true</code>.
         * @param pVal
         * @return
         */
        public Builder flattenedMultiValueOutputs(boolean pVal) {
            flattenedMultiValueOutputs = pVal;
            return this;
        }

        @Override
        public JoinOutputRule build() {
            try {
                String[] keyAry = new String[] {ruleNames.stream().collect(Collectors.joining("-"))};
                String cacheKey = generateCacheKey(keyAry);
                Rule r = getRuleCache().get(cacheKey);

                if (null == r) {
                    r = new JoinOutputRule(this);
                    r = uniqueRule(r, cacheKey);
                }
                storeInRuleByNameCache(r, name);
                return (JoinOutputRule) r;
            } catch (RuleException e) {
                throw new IllegalArgumentException(e);
            }
        }
    }


    private JoinOutputRule(Builder pBuilder) throws RuleNameNotFoundException {
        super(pBuilder.name);
        List<Rule> tempList = new ArrayList(pBuilder.ruleNames.size());
        for (String ruleName : pBuilder.ruleNames) {
            Rule rule = lookupRuleByName(ruleName);
            tempList.add(rule);
        }
        rules = Collections.unmodifiableList(tempList);
        delimiter = pBuilder.delimiter;
        flattenedMultiValueOutputs = pBuilder.flattenedMultiValueOutputs;
    }



    @Override
    public <T extends SearchPath, U extends Filter, V extends TargetElements>
    RuleExecutionResult applyBody(Context pContext,
                                  T pSearchPath,
                                  U pFilter,
                                  V pTargetElems,
                                  Map<String, String> pExtraParams) throws RuleException {
        List<List<String>> lists = new ArrayList<>();
        lists.add(new ArrayList<>());
        for (Rule r : rules) {
            RuleExecutionResult res = r.apply(pContext, pSearchPath, pFilter, pTargetElems, pExtraParams);
            String ruleResultVal = res.evaluateResultAsString();
            List<String> toAdd = new ArrayList<>();
            /**
             * Get the output of this rule, which can be either a list (|| separated tokens), or
             * a single value.
             */
            if (ruleResultVal.indexOf(Utilities.MULTI_VAL_DELIM) > 0) {
                String[] vals = ruleResultVal.split(Pattern.quote(Utilities.MULTI_VAL_DELIM));
                for (String v : vals) {
                    toAdd.add(v);
                }
            } else {
                if (CommonUtils.stringIsBlank(ruleResultVal)) {
                    toAdd.add(RuleConstants.BLANK_TOKEN);
                } else {
                    toAdd.add(ruleResultVal);
                }
            }


            /**
             * Do the "if()" below if we're producing a flattened list. Also do the "if()" until the time comes
             * that there's actually outputs to combine (I.e. the rule above gave multi-value output and
             * the only existing sub-list is no longer empty because of previously added rule outputs, in which
             * case time to combine outputs baby!).
             */
            if (flattenedMultiValueOutputs
                    || (lists.size() == 1 && (toAdd.size() == 1 || lists.get(0).size() == 0 && toAdd.size() > 1))) {
                lists.get(0).addAll(toAdd);
            } else {
                List<List<String>> newLists = new ArrayList<>();
                for (String s : toAdd) {
                    List<String> newSubList = new ArrayList<>();
                    newLists.add(newSubList);
                    for (List<String> l : lists) {
                        newSubList.addAll(l);
                        newSubList.add(s);
                    }
                }
                lists.clear();
                lists.addAll(newLists);
            }
        }

        Map<String, String> info = populateCommonResultProperties(
                pContext, pSearchPath, pFilter, pTargetElems, pExtraParams, SearchResult.emptySearchResult());
        return new TextOutputRuleExecutionResult(Boolean.TRUE, info, prepareReturnString(lists), pContext, getOutputFieldMap());
    }


    /**
     * Takes the list of lists, separates them with {@link Utilities#MULTI_VAL_DELIM}, and each within
     * each sub-list the individual members are separated by {@link this#delimiter}.
     * @param pLists
     * @return
     */
    private String prepareReturnString(List<List<String>> pLists) {
        List<String> subLists = new ArrayList<>();
        for (List<String> l : pLists) {
            subLists.add(l.stream().collect(Collectors.joining(String.valueOf(delimiter))));
        }
        return subLists.stream().collect(Collectors.joining(Utilities.MULTI_VAL_DELIM));
    }
}
